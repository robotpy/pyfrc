
from .elements import DrawableLine
from .elements import TextElement

from ... import config

import tkinter as tk

class UserRenderer:

    # sad global
    _global_ui = None
    _global_robot = None
    _renderers = []
    
    @classmethod
    def _attach_ui(cls, ui, robot):
        cls._global_ui = ui
        cls._global_robot = robot
        for renderer in cls._renderers:
            for deferred in renderer._deferred:
                deferred()
            del renderer._deferred
    
    def __init__(self):
        self._elements = []
        self._deferred = []
        self._renderers.append(self)

    def clear(self):
        for e in self._elements:
            e.delete()
            
    # draw a line in robot coordinates
    
    # draw a line in field coordinates
    # -> maybe just convert?
    
    # draw pathfinder?
    def draw_pathfinder_trajectory(self, trajectory, color='#ff0000', offset=None, scale=(1,1),
                                         show_dt=False, dt_offset=0.0, **kwargs):
        '''
            Special helper function for drawing trajectories generated by
            robotpy-pathfinder
            
            :param trajectory: A list of pathfinder segment objects
            :param offset: If specified, should be x/y tuple to add to the path
                           relative to the robot coordinates
            :param scale: Multiply all points by this (x,y) tuple
            :param show_dt: draw text every N seconds along path, or False
            :param dt_offset: add this to each dt shown
            :param kwargs: Keyword options to pass to tkinter.create_line
        '''
        # pathfinder x/y coordinates are switched
        pts = [(pt.x, -pt.y) for pt in trajectory]
        robot_coordinates = offset if offset else True
        self.draw_line(pts, color=color, robot_coordinates=robot_coordinates,
                      relative_to_first=True, arrow=True, scale=scale)
        
        if show_dt:
            dt = trajectory[0].dt
            def _defer_text():
                # defer this execution to save effort when drawing
                px_per_ft = UserRenderer._global_ui.field.px_per_ft
                line = self._elements[-1]
                
                for i in range(0, len(pts), int(show_dt/dt)):
                    text = 't=%.2f' % (dt_offset + i*dt,)
                    el = TextElement(text, line.pts[i], 0, '#000000', int(px_per_ft*.5))
                    UserRenderer._global_ui.field.add_moving_element(el)
                    self._elements.append(el)
                
            self._run(_defer_text)
        
    def draw_line(self, line_pts, color='#ff0000',
                  robot_coordinates=False, relative_to_first=False,
                  arrow=True, scale=(1,1), **kwargs):
        '''
            :param line_pts: A list of (x,y) pairs to draw. (x,y) are in field units
                             which are measured in feet
            :param color: The color of the line, expressed as a 6-digit hex color
            :param robot_coordinates: If True, the pts will be adjusted such that
                                      the first point starts at the center
                                      of the robot and that x and y coordinates
                                      are rotated according to the robot's
                                      current heading. If a tuple, then the pts
                                      are adjusted relative to the robot center
                                      AND the x,y in the tuple
            :param relative_to_first: If True, the points will be adjusted such
                                      that the first point is considered to be
                                      (0,0)
            :param arrow: If True, draw the line with an arrow at the end
            :param scale: Multiply all points by this (x,y) tuple
            :param kwargs: Keyword options to pass to tkinter.create_line
        '''
        def _defer(): # called later because the field might not exist yet
            px_per_ft = UserRenderer._global_ui.field.px_per_ft
            if arrow:
                kwargs['arrow'] = 'last'
            sx, sy = scale
            line = DrawableLine([(x*px_per_ft*sx, y*px_per_ft*sy) for x,y in line_pts], color, kwargs)
            
            # if relative to first, create object, then move relative to the first
            if relative_to_first:
                line.move((-line.pts[0][0], -line.pts[0][1]))
            
            if robot_coordinates:
                self._do_robot_coordinates(line, robot_coordinates)
                
            line.update_coordinates()
            UserRenderer._global_ui.field.add_moving_element(line)
            self._elements.append(line)
            
        self._run(_defer)
    
    def draw_text(self, text, pt, color='#000000', fontSize=10,
                        robot_coordinates=False, scale=(1,1), **kwargs):
        '''
            :param text: Text to render
            :param pt: A tuple of (x,y) in field units (which are measured in feet)
            :param color: The color of the text, expressed as a 6-digit hex color
            :param robot_coordinates: If True, the pt will be adjusted such that
                                      the point starts at the center of the
                                      robot and that x and y coordinates are
                                      rotated according to the robot's current
                                      heading. If a tuple, then the pt
                                      is adjusted relative to the robot center
                                      AND the x,y in the tuple
            :param arrow: If True, draw the line with an arrow at the end
            :param scale: Multiply all points by this (x,y) tuple
            :param kwargs: Keyword options to pass to tkinter.create_text
        '''
        x, y = pt
        
        def _defer(): # called later because the field might not exist yet
            px_per_ft = UserRenderer._global_ui.field.px_per_ft
            sx, sy = scale
            pt = ((x*px_per_ft*sx), (y*px_per_ft*sy))
            
            el = TextElement(text, pt, 0, color, fontSize, **kwargs)
            
            if robot_coordinates:
                self._do_robot_coordinates(el, robot_coordinates)
            
            el.update_coordinates()
            UserRenderer._global_ui.field.add_moving_element(el)
            self._elements.append(el)
        
        self._run(_defer)
    
    def _do_robot_coordinates(self, el, robot_coordinates):
        px_per_ft = UserRenderer._global_ui.field.px_per_ft
        x, y = UserRenderer._global_robot.center
        angle = UserRenderer._global_robot.angle
        el.move((x,y))
        
        if isinstance(robot_coordinates, (list, tuple)):
            el.move((px_per_ft*robot_coordinates[1], px_per_ft*robot_coordinates[0]))
        
        # for rotation to work, rotate it about the front center of the robot
        el.center = (x,y)
        el.rotate(angle)
        
    def _run(self, d):
        # TODO: need to idle_add this
        if UserRenderer._global_ui:
            UserRenderer._global_ui.idle_add(d)
        else:
            self._deferred.append(d)


def get_user_renderer():
    '''
        This retrieves an object that can be used to draw on the simulated field
        when running the robot in simulation.
    
        :returns: None if no renderers are available, else a :class:`.UserRenderer` object
    '''
    if config.mode != 'sim':
        return

    return UserRenderer()
  
