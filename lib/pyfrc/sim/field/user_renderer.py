from .elements import DrawableLine
from .elements import TextElement

from ... import config

import tkinter as tk


class UserRenderer:

    # sad global
    _global_ui = None
    _global_robot = None
    _renderers = []

    @classmethod
    def _attach_ui(cls, ui, robot):
        cls._global_ui = ui
        cls._global_robot = robot
        for renderer in cls._renderers:
            for deferred in renderer._deferred:
                deferred()
            del renderer._deferred

    def __init__(self):
        self._elements = []
        self._deferred = []
        self._renderers.append(self)

    def clear(self):
        for e in self._elements:
            e.delete()

    # draw a line in robot coordinates

    # draw a line in field coordinates
    # -> maybe just convert?

    # draw pathfinder?
    def draw_pathfinder_trajectory(
        self,
        trajectory,
        color="#ff0000",
        offset=None,
        scale=(1, 1),
        show_dt=False,
        dt_offset=0.0,
        **kwargs
    ):
        """
            Special helper function for drawing trajectories generated by
            robotpy-pathfinder
            
            :param trajectory: A list of pathfinder segment objects
            :param offset: If specified, should be x/y tuple to add to the path
                           relative to the robot coordinates
            :param scale: Multiply all points by this (x,y) tuple
            :param show_dt: draw text every N seconds along path, or False
            :param dt_offset: add this to each dt shown
            :param kwargs: Keyword options to pass to tkinter.create_line
        """
        # pathfinder x/y coordinates are switched
        pts = [(pt.x, -pt.y) for pt in trajectory]
        robot_coordinates = offset if offset else True
        self.draw_line(
            pts,
            color=color,
            robot_coordinates=robot_coordinates,
            relative_to_first=True,
            arrow=True,
            scale=scale,
        )

        if show_dt:
            dt = trajectory[0].dt

            def _defer_text():
                # defer this execution to save effort when drawing
                px_per_ft = UserRenderer._global_ui.field.px_per_ft
                line = self._elements[-1]

                for i in range(0, len(pts), int(show_dt / dt)):
                    text = "t=%.2f" % (dt_offset + i * dt,)
                    el = TextElement(
                        text, line.pts[i], 0, "#000000", int(px_per_ft * .5)
                    )
                    UserRenderer._global_ui.field.add_moving_element(el)
                    self._elements.append(el)

            self._run(_defer_text)

    def draw_line(
        self,
        line_pts,
        color="#ff0000",
        robot_coordinates=False,
        relative_to_first=False,
        arrow=True,
        scale=(1, 1),
        **kwargs
    ):
        """
            :param line_pts: A list of (x,y) pairs to draw. (x,y) are in field units
                             which are measured in feet
            :param color: The color of the line, expressed as a 6-digit hex color
            :param robot_coordinates: If True, the pts will be adjusted such that
                                      the first point starts at the center
                                      of the robot and that x and y coordinates
                                      are rotated according to the robot's
                                      current heading. If a tuple, then the pts
                                      are adjusted relative to the robot center
                                      AND the x,y in the tuple
            :param relative_to_first: If True, the points will be adjusted such
                                      that the first point is considered to be
                                      (0,0)
            :param arrow: If True, draw the line with an arrow at the end
            :param scale: Multiply all points by this (x,y) tuple
            :param kwargs: Keyword options to pass to tkinter.create_line
        """

        def _defer():  # called later because the field might not exist yet
            px_per_ft = UserRenderer._global_ui.field.px_per_ft
            if arrow:
                kwargs["arrow"] = "last"
            sx, sy = scale
            line = DrawableLine(
                [(x * px_per_ft * sx, y * px_per_ft * sy) for x, y in line_pts],
                color,
                kwargs,
            )

            # if relative to first, create object, then move relative to the first
            if relative_to_first:
                line.move((-line.pts[0][0], -line.pts[0][1]))

            if robot_coordinates:
                self._do_robot_coordinates(line, robot_coordinates)

            line.update_coordinates()
            UserRenderer._global_ui.field.add_moving_element(line)
            self._elements.append(line)

        self._run(_defer)

    def draw_text(
        self,
        text,
        pt,
        color="#000000",
        fontSize=10,
        robot_coordinates=False,
        scale=(1, 1),
        **kwargs
    ):
        """
            :param text: Text to render
            :param pt: A tuple of (x,y) in field units (which are measured in feet)
            :param color: The color of the text, expressed as a 6-digit hex color
            :param robot_coordinates: If True, the pt will be adjusted such that
                                      the point starts at the center of the
                                      robot and that x and y coordinates are
                                      rotated according to the robot's current
                                      heading. If a tuple, then the pt
                                      is adjusted relative to the robot center
                                      AND the x,y in the tuple
            :param arrow: If True, draw the line with an arrow at the end
            :param scale: Multiply all points by this (x,y) tuple
            :param kwargs: Keyword options to pass to tkinter.create_text
        """
        x, y = pt

        def _defer():  # called later because the field might not exist yet
            px_per_ft = UserRenderer._global_ui.field.px_per_ft
            sx, sy = scale
            pt = ((x * px_per_ft * sx), (y * px_per_ft * sy))

            el = TextElement(text, pt, 0, color, fontSize, **kwargs)

            if robot_coordinates:
                self._do_robot_coordinates(el, robot_coordinates)

            el.update_coordinates()
            UserRenderer._global_ui.field.add_moving_element(el)
            self._elements.append(el)

        self._run(_defer)

    def _do_robot_coordinates(self, el, robot_coordinates):
        px_per_ft = UserRenderer._global_ui.field.px_per_ft
        x, y = UserRenderer._global_robot.center
        angle = UserRenderer._global_robot.angle
        el.move((x, y))

        if isinstance(robot_coordinates, (list, tuple)):
            el.move(
                (px_per_ft * robot_coordinates[1], px_per_ft * robot_coordinates[0])
            )

        # for rotation to work, rotate it about the front center of the robot
        el.center = (x, y)
        el.rotate(angle)

    def _run(self, d):
        # TODO: need to idle_add this
        if UserRenderer._global_ui:
            UserRenderer._global_ui.idle_add(d)
        else:
            self._deferred.append(d)


def get_user_renderer():
    """
        This retrieves an object that can be used to draw on the simulated field
        when running the robot in simulation.
    
        :returns: None if no renderers are available, else a :class:`.UserRenderer` object
    """
    if config.mode != "sim":
        return

    return UserRenderer()
